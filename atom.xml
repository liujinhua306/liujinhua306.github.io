<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blogs.liusuisui.cn</id>
    <title>suisuipingan</title>
    <updated>2019-06-26T05:57:18.345Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blogs.liusuisui.cn"/>
    <link rel="self" href="http://blogs.liusuisui.cn/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://blogs.liusuisui.cn/images/avatar.png</logo>
    <icon>http://blogs.liusuisui.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, suisuipingan</rights>
    <entry>
        <title type="html"><![CDATA[Java通过URLClassLoader让程序支持插件扩展]]></title>
        <id>http://blogs.liusuisui.cn/post/chajian</id>
        <link href="http://blogs.liusuisui.cn/post/chajian">
        </link>
        <updated>2019-06-26T03:33:25.000Z</updated>
        <content type="html"><![CDATA[<p>插件(Plugin)是什么不用多说。常用的软件，例如Eclipse、Photoshop、VisualStudio，都支持插件扩展。插件可以动态给软件添加一些功能，也可以随时删除，这样的好处是任何人都可以给这个软件进行功能上的扩展，而不用去改软件本身的代码。
<a name="IucKb"></a></p>
<h2 id=""><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"></a>适用场景</h2>
<p>比如需要开发一个系统，用来将一些有数据推送给客户，至于是什么数据不是重点。有三个客户：A客户需要把数据组织成一个xml格式的文件，通过FTP上传到客户服务器上；B客户需要把数据组织成一个json，通过HTTP请求提交；C客户希望生成一个Excel文件再通过E-mail发送…以后可能还会有更多的客户，也还会有更多操蛋的需求。<br />对于这样一个系统的开发，如果使用普通的方式开发，那么每增加一个客户就要修改一次系统代码，在代码中增加一个针对某个客户的功能，很不灵活。如果再减少一个客户，那么其对应的代码也就没有用了，是不是要删除掉又成了问题。<br />以上只是一个例子，在实际开发中经常会有类似的情形，此时使用插件化的方式会更灵活。<br />遇到这种情况，可以把数据的获取和整理这块和客户无关的逻辑放在主程序中，而主程序提供一个客户推送的接口，接口定义一个未实现的抽象方法“推送数据”，这个方法由各个客户对应的插件来实现。这样新增一个客户需求，不需要修改主程序的代码，只需要实现这个接口就行，插件写好打成jar包放在指定目录下，再配置一下，主程序就可以使用这个插件了。当不需要这个插件，也可以通过配置来去掉它。
<a name="47bFo"></a></p>
<h2 id="-2"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6"></a>主程序配置插件</h2>
<p>上面说到主程序可以通过配置来动态添加和删除插件，配置的方式一般有两种：XML或数据库，二者选其一即可。
<a name="nxtNT"></a></p>
<h3 id="-3"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AXML"></a>方法一：XML</h3>
<p>主程序可以通过一个xml配置文件，动态配置插件。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;plugins&gt;
	&lt;plugin&gt;
		&lt;name&gt;A客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/a-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.aplugin.APlugin&lt;/class&gt;
	&lt;/plugin&gt;
	&lt;plugin&gt;
		&lt;name&gt;B客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/b-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.bplugin.BPlugin&lt;/class&gt;
	&lt;/plugin&gt;
	&lt;plugin&gt;
		&lt;name&gt;C客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/c-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.cplugin.CPlugin&lt;/class&gt;
	&lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<p>主程序通过解析这个XML来调用插件，<plugin>元素即一个插件，可以通过添加和删除<plugin>元素来动态的添加和删除插件。<name>是插件名称，<jar>是插件jar文件所在的路径，<class>是插件实现主程序接口的类。
<a name="qWqs4"></a></p>
<h3 id="-4"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93"></a>方法二：数据库</h3>
<p>如果使用数据库来配置插件，需要一个插件表（plugin_info）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">jar</th>
<th style="text-align:left">class</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">A客户插件</td>
<td style="text-align:left">D:/plugin/a-plugin.jar</td>
<td style="text-align:left">com.xxg.aplugin.APlugin</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">B客户插件</td>
<td style="text-align:left">D:/plugin/b-plugin.jar</td>
<td style="text-align:left">com.xxg.bplugin.BPlugin</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">C客户插件</td>
<td style="text-align:left">D:/plugin/c-plugin.jar</td>
<td style="text-align:left">com.xxg.cplugin.CPlugin</td>
</tr>
</tbody>
</table>
<p><a name="dVHbg"></a></p>
<h3 id="-5"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"></a>两种方法的区别</h3>
<p>两种方式从功能上来说是一样的。使用数据库方式的好处是可以很方遍的再开发一个管理界面来管理，不好的地方就是依赖数据库。
<a name="Yg8Li"></a></p>
<h2 id="-6"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E4%B8%BB%E7%A8%8B%E5%BA%8F"></a>主程序</h2>
<p>下面是以XML作为插件配置方式的调用插件的主程序。<br />主程序需要提供一个接口来提供给插件开发者来实现：</p>
<pre><code class="language-java">package com.xxg.main;

public interface PluginService {
	public void service();
}
</code></pre>
<p>上面是一个接口，包含一个未实现的方法service()，这个方法即和客户相关的逻辑，由插件来实现。<br />插件封装类：</p>
<pre><code class="language-java">package com.xxg.main;

public class Plugin {
	private String name;
	
	private String jar;
	
	private String className;
	
	// setter、getter省略…
}
</code></pre>
<p>解析XML获取所有插件信息（这里用到dom4j）：</p>
<pre><code class="language-java">package com.xxg.main;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

public class XMLParser {
	public static List&lt;Plugin&gt; getPluginList() throws DocumentException {
		List&lt;Plugin&gt; list = new ArrayList&lt;Plugin&gt;();
		
		SAXReader saxReader =new SAXReader();
		Document document = saxReader.read(new File(&quot;plugin.xml&quot;));
		Element root = document.getRootElement();
		List&lt;?&gt; plugins = root.elements(&quot;plugin&quot;);
		for(Object pluginObj : plugins) {
			Element pluginEle = (Element)pluginObj;
			Plugin plugin = new Plugin();
			plugin.setName(pluginEle.elementText(&quot;name&quot;));
			plugin.setJar(pluginEle.elementText(&quot;jar&quot;));
			plugin.setClassName(pluginEle.elementText(&quot;class&quot;));
			list.add(plugin);
		}
		return list;
	}
}
</code></pre>
<p>使用URLClassLoader动态加载jar文件，实例化插件中的对象：</p>
<pre><code class="language-java">package com.xxg.main;

import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.List;

public class PluginManager {
	private URLClassLoader urlClassLoader;

	public PluginManager(List&lt;Plugin&gt; plugins) throws MalformedURLException {
		init(plugins);
	}
	
	private void init(List&lt;Plugin&gt; plugins) throws MalformedURLException {
		int size = plugins.size();
		URL[] urls = new URL[size];
		
		for(int i = 0; i &lt; size; i++) {
			Plugin plugin = plugins.get(i);
			String filePath = plugin.getJar();

			urls[i] = new URL(&quot;file:&quot; + filePath);
		}
		
		// 将jar文件组成数组，来创建一个URLClassLoader
		urlClassLoader = new URLClassLoader(urls);
	}
	
	public PluginService getInstance(String className) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		// 插件实例化对象，插件都是实现PluginService接口
		Class&lt;?&gt; clazz = urlClassLoader.loadClass(className);
		Object instance = clazz.newInstance();

		return (PluginService)instance;
	}
}
</code></pre>
<p>main函数依次调用插件逻辑：</p>
<pre><code class="language-java">package com.xxg.main;

import java.util.List;

public class Main {
	public static void main(String[] args) {
		try {
			List&lt;Plugin&gt; pluginList = XMLParser.getPluginList();
			PluginManager pluginManager = new PluginManager(pluginList);
			for(Plugin plugin : pluginList) {
				PluginService pluginService = pluginManager.getInstance(plugin.getClassName());
				System.out.println(&quot;开始执行[&quot; + plugin.getName() + &quot;]插件...&quot;);
				// 调用插件
				pluginService.service();
				System.out.println(&quot;[&quot; + plugin.getName() + &quot;]插件执行完成&quot;);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
</code></pre>
<p><a name="MdRRD"></a></p>
<h2 id="插件开发">插件开发</h2>
<p>插件开发很简单，只需要把主程序的jar包引入到项目中，再实现主程序提供的接口就行：</p>
<pre><code class="language-java">package com.xxg.aplugin;

import com.xxg.main.PluginService;

public class APlugin implements PluginService {
	@Override
	public void service() {
		System.out.println(&quot;A客户插件正在执行~&quot;);
	}
}
</code></pre>
<p>service()方法应该实现客户相关的逻辑，即实现插件的功能。这里就用一句System.out.println来代替。<br />插件实现完成后，打个jar包，注意不要把主程序的部分也打到jar里。<br />再实现其他插件，插件实现完成后，配置主程序的plugin.xml。
<a name="m16sr"></a></p>
<h2 id="-7"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"></a>运行程序</h2>
<p>配置好plugin.xml，插件jar放到配置的路径下。<br />运行主程序main方法：<br /><em>开始执行[A客户插件]插件…</em><br /><em>A客户插件正在执行~</em><br /><em>[A客户插件]插件执行完成</em><br /><em>开始执行[B客户插件]插件…</em><br /><em>B客户插件正在执行~</em><br /><em>[B客户插件]插件执行完成</em><br /><em>开始执行[C客户插件]插件…</em><br /><em>C客户插件正在执行~</em><br /><em>[C客户插件]插件执行完成</em><br />以上，就完成了主程序和插件的开发。
<a name="YMW8w"></a></p>
<h2 id="-8"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#%E6%89%A9%E5%B1%95%EF%BC%9Aservice-%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC"></a>扩展：service()参数、返回值</h2>
<p>如果逻辑需要的话，service()可以添加参数和返回值。例如主程序需要传入数据给插件，可以加入参数，插件需要返回结果给主程序，可以加入返回值。<br />例如传给插件一些插件需要的配置项。在上面的场景中，各个客户的需求不同。A需要FTP上传，那么需要FTP服务器的地址、端口号、用户名、密码配置项；B需要HTTP请求，那么需要请求地址配置项；C需要发送邮件，那么需要e-mail地址配置项。<br />这些配置项可以统一配置在XML或数据库中。
<a name="XML"></a></p>
<h3 id="-9"><a href="http://xxgblog.com/2013/07/04/java-urlclassloader-plugin/#XML"></a>XML</h3>
<p>每个插件元素中加入<properties>元素来配置。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;plugins&gt;
	&lt;plugin&gt;
		&lt;name&gt;A客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/a-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.aplugin.APlugin&lt;/class&gt;
		&lt;properties&gt;
			&lt;property name=&quot;FTP_IP&quot;&gt;192.168.7.1&lt;/property&gt;
			&lt;property name=&quot;FTP_PORT&quot;&gt;21&lt;/property&gt;
			&lt;property name=&quot;FTP_USERNAME&quot;&gt;XXG&lt;/property&gt;
			&lt;property name=&quot;FTP_PASSWORD&quot;&gt;123456&lt;/property&gt;
		&lt;/properties&gt;
	&lt;/plugin&gt;
	&lt;plugin&gt;
		&lt;name&gt;B客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/b-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.bplugin.BPlugin&lt;/class&gt;
		&lt;properties&gt;
			&lt;property name=&quot;URL&quot;&gt;http://www.xxg.com/api&lt;/property&gt;
		&lt;/properties&gt;
	&lt;/plugin&gt;
	&lt;plugin&gt;
		&lt;name&gt;C客户插件&lt;/name&gt;
		&lt;jar&gt;D:/plugin/c-plugin.jar&lt;/jar&gt;
		&lt;class&gt;com.xxg.cplugin.CPlugin&lt;/class&gt;
		&lt;properties&gt;
			&lt;property name=&quot;EMAIL&quot;&gt;xxg@xxg.com&lt;/property&gt;
		&lt;/properties&gt;
	&lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<p><a name="gUJqx"></a></p>
<h3 id="数据库">数据库</h3>
<p>如果使用数据库配置的话，数据库要再加一个插件配置表（plugin_config_info）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">plugin_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">FTP_IP</td>
<td style="text-align:left">192.168.7.1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">FTP_PORT</td>
<td style="text-align:left">21</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
<td style="text-align:left">FTP_USERNAME</td>
<td style="text-align:left">XXG</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">1</td>
<td style="text-align:left">FTP_PASSWORD</td>
<td style="text-align:left">123456</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">URL</td>
<td style="text-align:left"><a href="http://www.xxg.com/api">http://www.xxg.com/api</a></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">3</td>
<td style="text-align:left">EMAIL</td>
<td style="text-align:left"><a href="mailto:xxg@xxg.com">xxg@xxg.com</a></td>
</tr>
</tbody>
</table>
<p>主程序定义接口，加入一个Map&lt;String,String&gt;参数来传入这些配置：</p>
<pre><code class="language-java">package com.xxg.main;

import java.util.Map;

public interface PluginService {
	public void service(Map&lt;String,String&gt; configs);
}
</code></pre>
<p>在插件中，可以获取这些配置：</p>
<pre><code class="language-java">package com.xxg.aplugin;

import java.util.Map;

import com.xxg.main.PluginService;

public class APlugin implements PluginService {
	@Override
	public void service(Map&lt;String, String&gt; configs) {
		String ftpIp = configs.get(&quot;FTP_IP&quot;);
		String ftpPort = configs.get(&quot;FTP_PORT&quot;);
		String ftpUsername = configs.get(&quot;FTP_USERNAME&quot;);
		String ftpPassword = configs.get(&quot;FTP_PASSWORD&quot;);
		
		// ...
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[嵌套练习]]></title>
        <id>http://blogs.liusuisui.cn/post/qian-tao-lian-xi</id>
        <link href="http://blogs.liusuisui.cn/post/qian-tao-lian-xi">
        </link>
        <updated>2019-06-26T03:22:22.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img.shields.io/badge/auth-liujinhua-blue.svg#align=left&amp;display=inline&amp;height=20&amp;originHeight=20&amp;originWidth=92&amp;status=done&amp;width=92" alt="">  <img src="https://img.shields.io/badge/postgresl-9.6-red.svg#align=left&amp;display=inline&amp;height=20&amp;originHeight=20&amp;originWidth=88&amp;status=done&amp;width=88" alt=""></p>
<pre><code class="language-sql">-- 表结构
-- 
-- 学生表student(id,name)
-- 列表项目
-- 课程表course(id,name)
-- 学生课程表student_course(sid,cid,score)
-- sql
create table student(
id int unsigned primary key auto_increment,
name char(10) not null
);
insert into student(name) values('张三'),('李四');

create table course(
id int unsigned primary key auto_increment,
name char(20) not null
);
insert into course(name) values('语文'),('数学');

create table student_course(
sid int unsigned,
cid int unsigned,
score int unsigned not null,
foreign key (sid) references student(id),
foreign key (cid) references course(id),
primary key(sid, cid)
);

insert into student_course values(1,1,80),(1,2,90),(2,1,90),(2,2,70);

--在student_course表中查询每门课成绩都不低于80的学生id
select distinct sid
from student_course
where sid not in (select sid from student_course where score &lt; 80);

-- 查询每个学生的总成绩，结果列出学生姓名和总成绩
select name,sum(score)
from student left join student_course
on student.id=student_course.sid
group by sid;


-- 在student_course表查询各科成绩最高的学生，结果列出学生id、课程id和对应的成绩
select * from student_course as x 
where score&gt;=(
 select max(score) from student_course as y 
 where cid=x.cid
 );
 
 --在student_course表中查询每门课的前2名，结果按课程id升序，同一课程按成绩降序 这个问题也就是取每组的前N条纪录
  select * from student_course x 
 where 2&gt;(
 select count(*) from student_course y 
 where y.cid=x.cid and y.score&gt;x.score
 ) 
order by cid,score desc;
--这也是一个相关嵌套查询，对于每一个分数，如果同一门课程下只有0个、1个分数比这个分数还高，那么这个分数肯定是前2名之一
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[exists练习]]></title>
        <id>http://blogs.liusuisui.cn/post/exists-lian-xi</id>
        <link href="http://blogs.liusuisui.cn/post/exists-lian-xi">
        </link>
        <updated>2019-06-26T03:16:24.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img.shields.io/badge/postgresl-9.6-red.svg#align=left&amp;display=inline&amp;height=24&amp;originHeight=20&amp;originWidth=88&amp;status=done&amp;width=106" alt=""></p>
<pre><code class="language-sql">-- 学生表
CREATE TABLE `student` (
  `id` int(11) NOT NULL,
  `name` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO student (`id`, `name`) VALUES ('100', 'xiaoming');
INSERT INTO student (`id`, `name`) VALUES ('101', 'tom');
INSERT INTO student (`id`, `name`) VALUES ('102', 'blue');
INSERT INTO student (`id`, `name`) VALUES ('103', 'jim');
INSERT INTO student (`id`, `name`) VALUES ('104', 'tonny');


-- 课程表
CREATE TABLE `course` (
  `id` int(11) NOT NULL,
  `C_NAME` varchar(20) DEFAULT NULL,
  `C_NO` varchar(10) DEFAULT NULL,
  KEY `id` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO course (`id`, `C_NAME`, `C_NO`) VALUES ('200', 'java', NULL);
INSERT INTO course (`id`, `C_NAME`, `C_NO`) VALUES ('201', 'php', NULL);
INSERT INTO course (`id`, `C_NAME`, `C_NO`) VALUES ('202', 'python', NULL);
INSERT INTO course (`id`, `C_NAME`, `C_NO`) VALUES ('203', 'c++', NULL);
INSERT INTO course (`id`, `C_NAME`, `C_NO`) VALUES ('204', 'c#', NULL);


-- 选课表
CREATE TABLE `select_course` (
  `id` int(11) NOT NULL,
  `STUDENT_ID` int(11) DEFAULT NULL,
  `COURSE_ID` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `foreign_key_stu` (`STUDENT_ID`),
  KEY `foreign_key_sou` (`COURSE_ID`),
  CONSTRAINT `foreign_key_sou` FOREIGN KEY (`COURSE_ID`) REFERENCES `course` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `foreign_key_stu` FOREIGN KEY (`STUDENT_ID`) REFERENCES `student` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('1', '100', '200');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('2', '100', '201');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('3', '100', '202');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('4', '100', '203');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('5', '100', '204');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('6', '101', '200');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('7', '101', '202');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('8', '101', '204');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('9', '102', '200');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('10', '102', '203');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('11', '102', '204');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('12', '103', '202');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('13', '103', '203');
INSERT INTO select_course (`id`, `STUDENT_ID`, `COURSE_ID`) VALUES ('15', '101', '203');


-- 查询选了所有课程的学生姓名--
SELECT
	NAME
FROM
	student s
WHERE
	NOT EXISTS (
		SELECT
			*
		FROM
			course c
		WHERE
			NOT EXISTS (
				SELECT
					*
				FROM
					select_course sc
				WHERE
					sc.student_id = s.id
				AND sc.course_id = c.id
			)
	);

-- 查询被所有学生都选了的课程名--
SELECT
	c.C_NAME
FROM
	course c
WHERE
	NOT EXISTS (
		SELECT
			*
		FROM
			student s
		WHERE
			NOT EXISTS (
				SELECT
					*
				FROM
					select_course sc
				WHERE
					sc.student_id = s.id
				AND sc.course_id = c.id
			)
	);

-- 查询至少选择了一门课程的学生姓名--
SELECT
	NAME
FROM
	student s
WHERE
	EXISTS (
		SELECT
			*
		FROM
			course c
		WHERE
			EXISTS (
				SELECT
					*
				FROM
					select_course sc
				WHERE
					sc.student_id = s.id
				AND sc.course_id = c.id
			)
	);

-- 查询一门课程也没选的学生姓名--
SELECT
	NAME
FROM
	student s
WHERE
	NOT EXISTS (
		SELECT
			*
		FROM
			course c
		WHERE
			EXISTS (
				SELECT
					*
				FROM
					select_course sc
				WHERE
					sc.student_id = s.id
				AND sc.course_id = c.id
			)
	);

-- 查询没有选择全部课程的学生姓名（包括一门也没选择的同学）
SELECT
	NAME
FROM
	student s
WHERE
	EXISTS (
		SELECT
			*
		FROM
			course c
		WHERE
			NOT EXISTS (
				SELECT
					*
				FROM
					select_course sc
				WHERE
					sc.student_id = s.id
				AND sc.course_id = c.id
			)
	);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[postgresql常用命令]]></title>
        <id>http://blogs.liusuisui.cn/post/postgresql-chang-yong-ming-ling</id>
        <link href="http://blogs.liusuisui.cn/post/postgresql-chang-yong-ming-ling">
        </link>
        <updated>2019-06-26T03:12:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img.shields.io/badge/author-liujinhua-blue.svg#align=left&amp;display=inline&amp;height=20&amp;originHeight=20&amp;originWidth=104&amp;status=done&amp;width=104" alt=""> 
<img src="https://img.shields.io/badge/postgresql-9.6-red.svg#align=left&amp;display=inline&amp;height=20&amp;originHeight=20&amp;originWidth=94&amp;status=done&amp;width=94" alt=""></p>
<p><a name="86fb9487"></a></p>
<h4 id="常规操作">常规操作</h4>
<ol>
<li>登录postgreSQL所在服务器</li>
<li>执行 psql -U postgres 启动postgreSQL终端</li>
<li>输入数据库密码 12345)(*&amp;^%RFVwsx</li>
<li>执行 \l 查看所有库</li>
<li>执行 \c NXSOC5 即访问NXSOC5数据库</li>
<li>即可执行相关SQL语句操作NXSOC5数据库</li>
<li>\d 表名 查看表结构</li>
</ol>
<p><a name="157d5306"></a></p>
<h4 id="创建数据库">创建数据库</h4>
<pre><code class="language-sql">CREATE DATABASE database_name;
</code></pre>
<p><a name="34609275"></a></p>
<h4 id="修改数据库名称及owner">修改数据库名称及owner</h4>
<pre><code class="language-sql">ALTER DATABASE name RENAME TO new_name

ALTER DATABASE name OWNER TO new_owner
</code></pre>
<p><a name="c40ae226"></a></p>
<h4 id="备份恢复数据库">备份/恢复数据库</h4>
<pre><code class="language-sql">-- postgres 数据库备份命令(该方式会生成二进制的压缩文件)
./pg_dump --host 127.0.0.1 --port 5432 --username &quot;postgres&quot;   --format custom --blobs --verbose --file &quot;/root/socdb.backup&quot; NXSOC_MG

-- NXSOC_MG 为要备份的数据库名。 输入命令后 会提示输入数据库密码。

-- postgres 数据库恢复命令(适合以上备份的方式)
./pg_restore -h 127.0.0.1 -p 5432 -U postgres -W -d NXSOC_MG -v &quot;/root/socdb.backup&quot;

-W 是强制口令提示
-- 输入命令后 会提示输入数据库密码。
</code></pre>
<p><a name="a301a2d4"></a></p>
<h4 id="增加表字段和修改表字段类型">增加表字段和修改表字段类型</h4>
<pre><code class="language-sql">alter table t_siem_dev_find alter  COLUMN  isnew type  int4 ;(修改字段)
alter table t_siem_dev_find add  COLUMN  isnew   int4 ;(增加字段)
</code></pre>
<p>注意： 把id的varchar变为int</p>
<pre><code class="language-sql">postgres=# alter table tb101 alter id type int;
ERROR:  column &quot;id&quot; cannot be cast automatically to type integer
HINT:  Specify a USING expression to perform the conversion.
</code></pre>
<p>上面这样执行后报错了<br />在没有隐式的转换下，就需要指定Using来显示的转换。</p>
<pre><code class="language-sql">postgres=# alter table tb101 alter id type int using id::int;
</code></pre>
<p><a name="14dc2110"></a></p>
<h4 id="子父表继承关系">子父表继承关系</h4>
<pre><code class="language-sql">-- 删除子表与父表的继承关系
alter table t_siem_original_log_20181106 no inherit t_siem_original_log
-- 添加子表与父表的继承关系
alter table t_siem_original_log_20181106  inherit t_siem_original_log
</code></pre>
<p><a name="b30cbcf3"></a></p>
<h4 id="备份表和恢复表">备份表和恢复表</h4>
<pre><code class="language-sql">-- 备份指定表
./pg_dump --host 127.0.0.1 --port 5432 --username &quot;postgres&quot; -Fc -t t_siem_threat_log  -f /threatTable.backup NXSOC5

-- 恢复单表
./pg_restore -h 127.0.0.1 -p 5432 -U postgres -W -d NXSOC5 -t ti_alarm -v &quot;/alarm.backup&quot;
-t指定表

-- 以insert into 的SQL语句导出
pg_dump -h 172.16.12.17 -U postgres --inserts -t  t_siem_moni_ne NXSOC5 &gt; /tmp/test1.sql
</code></pre>
<p><a name="1d259eb8"></a></p>
<h4 id="查看postgresql的oid和表占磁盘大小">查看postgresql的oid和表占磁盘大小</h4>
<pre><code class="language-sql">-- 查看数据库oid
select oid,datname from pg_database; 
-- 查看表的oid
select oid from pg_class where relname='t_siem_alarm_active' ;
select 
-- 查看表占磁盘大小pg_size_pretty(pg_relation_size('t_siem_original_log_201809_39'));
</code></pre>
<p><a name="e0e3ddfc"></a></p>
<h4 id="postgresql时间操作">postgresql时间操作</h4>
<pre><code class="language-sql">-- 当前时间减去两个月
SELECT CURRENT_DATE-interval'2 month');
</code></pre>
<p><a name="f6d2fa2b"></a></p>
<h4 id="删除表的规则">删除表的规则</h4>
<pre><code class="language-sql">DROP RULE &quot;rule_t_siem_original_log_20190426&quot; ON &quot;public&quot;.&quot;t_siem_original_log&quot;;
</code></pre>
<p><a name="75be9192"></a></p>
<h4 id="sql拼接">sql拼接</h4>
<pre><code class="language-sql">Select CONCAT( 'drop table ', tablename, ';' ) 
FROM pg_tables
Where tablename like 't_siem_original_log_%' and tablename &lt; 't_siem_original_log_201901_2';
</code></pre>
<p><a name="5512d417"></a></p>
<h4 id="字符串截取">字符串截取</h4>
<pre><code class="language-sql">update  t_portal_monitor_table  set srccity= substring(sitekindname from 1 for 2) where  createdatetime&gt; '2019-01-02 00:00:00'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[postgresql 脚本语句练习]]></title>
        <id>http://blogs.liusuisui.cn/post/postgresql</id>
        <link href="http://blogs.liusuisui.cn/post/postgresql">
        </link>
        <updated>2019-06-26T03:09:15.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-sql">DO
$do$
BEGIN
IF EXISTS (SELECT 1 FROM orders) THEN
   DELETE FROM orders;
ELSE 
   INSERT INTO orders VALUES (1,2,3);
END IF;
END
$do$
</code></pre>
<pre><code class="language-sql">-- 查询t_sys_menu表的id并赋值给menu变量（menu变量是RECORD类型的） 然后for循环 查询t_sys_role_resource表
-- 中是否有该menuid的记录。没有就插入。 
DO $body$ DECLARE
menu RECORD;
BEGIN
    FOR menu IN ( SELECT recordid FROM t_sys_menu )
    LOOP
  IF
    ( SELECT COUNT ( 1 ) FROM t_sys_role_resource WHERE roleid = '1' AND menuid = menu.recordid ) = 0 --一定要加括号
  THEN
      INSERT INTO &quot;public&quot;.&quot;t_sys_role_resource&quot; ( &quot;recordid&quot;, &quot;roleid&quot;, &quot;menuid&quot;, &quot;buttons&quot; )
    VALUES
      ( menu.recordid, '1', menu.recordid, NULL );
    ELSE 
    --nothing to do;
    
  END IF;
  
END LOOP;

END;
$body$ LANGUAGE PLPGSQL;
</code></pre>
<pre><code class="language-sql">-- 查询出menuid后再赋值给menu_id
DO $body$ DECLARE
menu_id VARCHAR ( 1000 );
BEGIN
    menu_id=(select menuid from t_sys_role_resource where recordid='800005003' );
    update t_sys_menu set flag=0 where recordid=menu_id;
END;
$body$ LANGUAGE PLPGSQL;
</code></pre>
]]></content>
    </entry>
</feed>